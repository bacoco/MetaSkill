#!/usr/bin/env python3
"""
Synapse Directive Generator
Creates skill creation directives from pattern analysis.

Instead of generating full skills, Synapse creates markdown directive files
that guide Claude to create appropriate skills using its native capabilities.

Generated by Synapse - Directive Generation Engine
"""

import json
import os
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import argparse


class DirectiveGenerator:
    """Generates skill creation directives from pattern analysis"""

    SKILL_TEMPLATES = {
        "testing": {
            "name": "test-guardian",
            "focus": "Automated testing and quality assurance",
            "capabilities": [
                "Generate test cases from code analysis",
                "Identify untested code paths",
                "Suggest test patterns and fixtures",
                "Auto-detect testing frameworks and conventions"
            ]
        },
        "deployment": {
            "name": "deploy-sage",
            "focus": "Deployment automation and infrastructure",
            "capabilities": [
                "Optimize Docker configurations",
                "Generate CI/CD pipeline configs",
                "Handle environment management",
                "Automate deployment scripts"
            ]
        },
        "documentation": {
            "name": "doc-genius",
            "focus": "Documentation generation and maintenance",
            "capabilities": [
                "Generate README files from code",
                "Create API documentation automatically",
                "Maintain inline documentation standards",
                "Generate usage examples"
            ]
        },
        "api": {
            "name": "api-master",
            "focus": "API development and integration",
            "capabilities": [
                "Rate limiting and retry logic",
                "Error handling patterns",
                "Response caching strategies",
                "API client generation"
            ]
        },
        "performance": {
            "name": "perf-optimizer",
            "focus": "Performance analysis and optimization",
            "capabilities": [
                "Identify performance bottlenecks",
                "Suggest caching strategies",
                "Optimize database queries",
                "Profile code execution"
            ]
        },
        "security": {
            "name": "security-shield",
            "focus": "Security analysis and hardening",
            "capabilities": [
                "Scan for common vulnerabilities",
                "Implement authentication patterns",
                "Validate input and sanitization",
                "Audit security configurations"
            ]
        },
        "refactoring": {
            "name": "code-refiner",
            "focus": "Code quality and refactoring",
            "capabilities": [
                "Identify code smells and anti-patterns",
                "Suggest refactoring opportunities",
                "Apply design patterns",
                "Improve code organization"
            ]
        },
        "data_processing": {
            "name": "data-wizard",
            "focus": "Data processing and transformation",
            "capabilities": [
                "ETL pipeline automation",
                "Data validation and cleaning",
                "Format conversion utilities",
                "Data analysis workflows"
            ]
        }
    }

    def __init__(self, output_dir: str = ".claude/skill-directives"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def generate_directive_from_recommendation(
        self,
        recommendation: Dict,
        patterns: List[Dict],
        soul_examples: List[str] = None
    ) -> str:
        """Generate a skill creation directive from pattern analysis"""

        skill_name = recommendation.get("skill_name", "custom-skill")
        skill_type = recommendation.get("skill_type", "general")
        description = recommendation.get("description", "")
        reason = recommendation.get("reason", "")
        priority_score = recommendation.get("priority_score", 0.5)
        detailed_scores = recommendation.get("detailed_scores", {})
        supporting_patterns = recommendation.get("supporting_patterns", [])
        example_use_cases = recommendation.get("example_use_cases", [])

        # Get template if available
        template = self.SKILL_TEMPLATES.get(skill_type, {})
        capabilities = template.get("capabilities", [])

        directive = f"""# {skill_name.upper()} Skill Creation Directive

**Generated by Synapse** on {self.timestamp}
**Priority Score**: {priority_score:.2f} ({"🔴 HIGH" if priority_score >= 0.7 else "🟡 MEDIUM" if priority_score >= 0.5 else "🟢 LOW"})

---

## 📊 Pattern Analysis Results

### Detection Summary
{reason}

### Detailed Scores
"""
        for score_name, score_value in detailed_scores.items():
            bar = "█" * int(score_value * 10) + "░" * (10 - int(score_value * 10))
            directive += f"- **{score_name.title()}**: {score_value:.2f} `{bar}`\n"

        directive += f"""
### Supporting Patterns ({len(supporting_patterns)})
"""
        for i, pattern in enumerate(supporting_patterns[:5], 1):
            directive += f"{i}. {pattern}\n"

        if len(supporting_patterns) > 5:
            directive += f"\n*...and {len(supporting_patterns) - 5} more patterns*\n"

        directive += f"""
---

## 🎯 Recommended Skill: {skill_name}

### Purpose
{description}

### Core Capabilities Needed
"""
        if capabilities:
            for cap in capabilities:
                directive += f"- {cap}\n"
        else:
            directive += f"""- Automate {skill_type} workflows
- Detect {skill_type} patterns automatically
- Apply {skill_type} best practices
- Provide intelligent {skill_type} assistance
"""

        if example_use_cases:
            directive += f"""
### Real Usage Examples from Cortex Data

Based on actual sessions where this skill would have been valuable:
"""
            for i, example in enumerate(example_use_cases[:5], 1):
                directive += f"{i}. {example}\n"

        directive += f"""
---

## 🔧 Implementation Guidance for Claude

### Skill Structure
Create a Claude skill with the following structure:
```
.claude/skills/{skill_name.lower()}/
├── SKILL.md (name: {skill_name.lower()}, description, activation triggers)
├── FORMS.md (optional configuration options)
├── examples.md (usage examples)
├── reference.md (technical details)
└── scripts/ (if helper scripts needed)
```

### Key Activation Triggers
Claude should activate {skill_name} when:
"""
        # Generate activation triggers based on skill type
        if skill_type == "testing":
            directive += """- User mentions tests, testing, or test coverage
- Detecting test files or test frameworks
- User requests quality assurance work
- Finding gaps in test coverage
"""
        elif skill_type == "api":
            directive += """- Working with API endpoints or HTTP requests
- User mentions rate limiting or API errors
- Detecting API integration challenges
- Need for request/response handling
"""
        elif skill_type == "documentation":
            directive += """- User mentions documentation, README, or docs
- Missing or outdated documentation detected
- Code changes need documentation updates
- User requests explanation or guides
"""
        else:
            directive += f"""- Detecting {skill_type}-related keywords and context
- User requests {skill_type} assistance
- {skill_type.title()} optimization opportunities identified
- Working with {skill_type} files or systems
"""

        directive += f"""
### Recommended Behavior
The skill should:
1. **Auto-detect** {skill_type} contexts without explicit user requests
2. **Suggest improvements** proactively when patterns are detected
3. **Apply best practices** automatically where safe
4. **Learn preferences** from user feedback and choices
5. **Integrate with Cortex** for session-to-session learning

### Configuration Options (FORMS.md)
Consider these user preferences:
- Automation level (conservative, balanced, aggressive)
- Notification preferences (silent, informative, verbose)
- Domain-specific settings for {skill_type}
- Integration with existing tools and workflows

---

## 📝 Directive Usage

**Next Steps:**
1. Review this directive to understand the skill need
2. Use your native skill creation capabilities to build the skill
3. Follow Claude Skills best practices for structure
4. Test the skill with actual {skill_type} scenarios
5. Iterate based on usage and feedback

**Remember:** This directive provides guidance, but you (Claude) have the intelligence to create the optimal skill implementation based on this analysis and the specific project context.

---

## 📈 Success Metrics

After creating this skill, success indicators include:
- Reduced time spent on {skill_type} tasks
- Fewer {skill_type}-related errors or issues
- More consistent {skill_type} patterns across sessions
- Positive user feedback on {skill_type} assistance
- Decreased mentions of {skill_type} problems in Cortex logs

---

*This directive was generated by Synapse pattern analysis. The actual skill implementation should be created by Claude using its native skill creation capabilities and adapting to the specific project needs.*
"""

        return directive

    def save_directive(self, directive_content: str, skill_name: str) -> Path:
        """Save directive to file"""
        filename = f"{skill_name.lower()}-directive.md"
        filepath = self.output_dir / filename

        with open(filepath, 'w') as f:
            f.write(directive_content)

        return filepath

    def generate_directives_from_report(self, report_path: str) -> List[Path]:
        """Generate directives from pattern detection report"""

        with open(report_path, 'r') as f:
            report = json.load(f)

        # Support both pattern detector reports and PRD analysis reports
        recommendations = report.get("recommendations", report.get("skill_recommendations", []))
        patterns = report.get("patterns", report.get("task_patterns", []))

        if not recommendations:
            print("No recommendations found in report")
            return []

        generated_files = []

        for rec in recommendations:
            # Get related patterns
            related_patterns = [p for p in patterns if any(
                sp in p.get("description", "")
                for sp in rec.get("supporting_patterns", [])
            )]

            # Generate directive
            directive = self.generate_directive_from_recommendation(
                rec,
                related_patterns,
                rec.get("example_use_cases", [])
            )

            # Save directive
            filepath = self.save_directive(directive, rec["skill_name"])
            generated_files.append(filepath)

            print(f"✓ Generated directive: {filepath}")

        return generated_files

    def create_index_file(self, directive_files: List[Path]):
        """Create index of all directives"""
        index_content = f"""# Synapse Skill Directives Index

Generated: {self.timestamp}

## Available Directives

These directives guide Claude in creating specialized skills based on detected patterns from Cortex analysis.

"""
        for filepath in sorted(directive_files):
            skill_name = filepath.stem.replace("-directive", "")
            index_content += f"- [{skill_name.upper()}](./{filepath.name})\n"

        index_content += f"""
---

## How to Use Directives

1. **Review a directive** to understand the detected need
2. **Claude reads the directive** and creates appropriate skill
3. **New skill is deployed** to `.claude/skills/`
4. **Skill becomes available** immediately for use

## Directive Generation

Directives are automatically generated by Synapse when:
- Pattern detector identifies recurring themes
- Priority score exceeds threshold
- Cortex data shows skill gap opportunities

---

*Synapse continuously monitors Cortex logs to identify optimization opportunities*
"""

        index_path = self.output_dir / "INDEX.md"
        with open(index_path, 'w') as f:
            f.write(index_content)

        print(f"\n✓ Created index: {index_path}")

    def generate_full_skill(self, recommendation: Dict, patterns: List[Dict]) -> Path:
        """Generate complete skill package (for systems without meta-skill)"""
        skill_name = recommendation.get("skill_name", "custom-skill").lower()
        skill_type = recommendation.get("skill_type", "general")
        description = recommendation.get("description", "")

        skill_dir = self.output_dir / skill_name
        skill_dir.mkdir(parents=True, exist_ok=True)

        scripts_dir = skill_dir / "scripts"
        scripts_dir.mkdir(exist_ok=True)

        # Create SKILL.md
        self._create_full_skill_md(skill_dir, recommendation)

        # Create FORMS.md
        self._create_full_forms_md(skill_dir, recommendation)

        # Create examples.md
        self._create_full_examples_md(skill_dir, recommendation)

        # Create reference.md
        self._create_full_reference_md(skill_dir, recommendation)

        # Create main script
        self._create_full_script(scripts_dir, recommendation)

        print(f"✓ Generated full skill package: {skill_dir}")
        return skill_dir

    def _create_full_skill_md(self, skill_dir: Path, rec: Dict):
        """Create SKILL.md for full skill"""
        skill_name = rec["skill_name"]
        description = rec["description"]
        skill_type = rec["skill_type"]

        content = f"""---
name: {skill_name.lower()}
description: {description} Automatically created by Synapse from detected patterns.
---

# {skill_name.upper()} - {skill_type.title()} Assistant

{description}

## What {skill_name.upper()} does

**Auto-Detection**: Recognizes {skill_type} contexts automatically
**Best Practices**: Applies industry standards and optimizations
**Error Prevention**: Anticipates common {skill_type} issues
**Intelligent Assistance**: Provides context-aware solutions

## When to use {skill_name.upper()}

Automatically activates when:
- Working with {skill_type}-related tasks
- Detecting {skill_type} optimization opportunities
- User mentions {skill_type} challenges
- {skill_type.title()} files or contexts detected

## Core Capabilities

"""
        for cap in rec.get("recommended_capabilities", []):
            content += f"- {cap}\n"

        content += f"""
## Real-World Usage

Based on detected patterns:
"""
        for example in rec.get("example_use_cases", [])[:3]:
            content += f"- {example}\n"

        content += f"""
---
*Generated by Synapse on {self.timestamp}*
"""

        with open(skill_dir / "SKILL.md", 'w') as f:
            f.write(content)

    def _create_full_forms_md(self, skill_dir: Path, rec: Dict):
        """Create FORMS.md for full skill"""
        skill_name = rec["skill_name"]
        skill_type = rec["skill_type"]

        content = f"""# {skill_name.upper()} Configuration

## Automation Level
**Conservative**: [ ] Only safe {skill_type} operations
**Balanced**: [ ] Most {skill_type} tasks (recommended)
**Aggressive**: [ ] Full {skill_type} automation

## Behavior Preferences
**Silent**: [ ] Work quietly in background
**Informative**: [ ] Notify on actions (recommended)
**Verbose**: [ ] Detailed explanations

## Configuration File

Create `.{skill_name.lower()}_config.json`:

```json
{{
  "automation_level": "balanced",
  "notification_mode": "informative",
  "{skill_type}_preferences": {{
    "auto_optimization": true,
    "best_practices": true,
    "error_prevention": true
  }}
}}
```

*Configuration is optional - {skill_name.upper()} works automatically*
"""

        with open(skill_dir / "FORMS.md", 'w') as f:
            f.write(content)

    def _create_full_examples_md(self, skill_dir: Path, rec: Dict):
        """Create examples.md for full skill"""
        skill_name = rec["skill_name"]
        skill_type = rec["skill_type"]

        content = f"""# {skill_name.upper()} Usage Examples

## Example 1: Automatic Detection

**User**: Working on {skill_type} task

**With {skill_name.upper()}**:
- Automatically detects {skill_type} context
- Applies optimizations transparently
- Provides intelligent assistance

## Example 2: Pattern Recognition

**User**: Encounters {skill_type} challenge

**With {skill_name.upper()}**:
- Recognizes problem pattern
- Suggests proven solutions
- Prevents common pitfalls

## Real Examples from Your Project

"""
        for i, example in enumerate(rec.get("example_use_cases", [])[:5], 1):
            content += f"{i}. {example}\n"

        content += f"""
---
*Generated by Synapse based on your actual usage patterns*
"""

        with open(skill_dir / "examples.md", 'w') as f:
            f.write(content)

    def _create_full_reference_md(self, skill_dir: Path, rec: Dict):
        """Create reference.md for full skill"""
        skill_name = rec["skill_name"]
        skill_type = rec["skill_type"]

        content = f"""# {skill_name.upper()} Technical Reference

## Activation Triggers

{skill_name.upper()} activates when:
- {skill_type.title()} keywords detected in conversation
- Working with {skill_type} files or systems
- User requests {skill_type} assistance
- {skill_type.title()} optimization opportunities identified

## Core Capabilities

"""
        for cap in rec.get("recommended_capabilities", []):
            content += f"### {cap}\n\n"

        content += f"""
## Configuration System

### .{skill_name.lower()}_config.json Structure
```json
{{
  "automation_level": "conservative|balanced|aggressive",
  "notification_mode": "silent|informative|verbose",
  "{skill_type}_preferences": {{
    "auto_optimization": boolean,
    "best_practices": boolean,
    "error_prevention": boolean
  }}
}}
```

## Pattern Detection

This skill was created based on:
- **Task Count**: {rec.get('task_count', 'N/A')} related tasks
- **Priority Score**: {rec.get('priority_score', 0):.2f}
- **Reason**: {rec.get('reason', 'Pattern detected')}

## Supporting Patterns

"""
        for pattern in rec.get("supporting_patterns", []):
            content += f"- {pattern}\n"

        content += f"""
---
*Generated by Synapse on {self.timestamp}*
"""

        with open(skill_dir / "reference.md", 'w') as f:
            f.write(content)

    def _create_full_script(self, scripts_dir: Path, rec: Dict):
        """Create helper script for full skill"""
        skill_name = rec["skill_name"]
        skill_type = rec["skill_type"]

        content = f'''#!/usr/bin/env python3
"""
{skill_name.upper()} Helper Script
Provides {skill_type} optimization and automation.
Generated by Synapse.
"""

import json
import os
from pathlib import Path

class {skill_name.replace("-", "").title()}Helper:
    def __init__(self):
        self.config = self.load_config()
        self.skill_type = "{skill_type}"

    def load_config(self):
        """Load skill configuration"""
        config_file = ".{skill_name.lower()}_config.json"
        if os.path.exists(config_file):
            with open(config_file) as f:
                return json.load(f)
        return self.get_default_config()

    def get_default_config(self):
        """Default configuration"""
        return {{
            "automation_level": "balanced",
            "notification_mode": "informative"
        }}

    def optimize(self, context):
        """Main optimization function"""
        print(f"{skill_name.upper()} optimizing {{self.skill_type}} context...")
        return f"Optimized: {{context}}"

if __name__ == "__main__":
    helper = {skill_name.replace("-", "").title()}Helper()
    print(f"{skill_name.upper()} initialized")
'''

        script_path = scripts_dir / f"{skill_type.replace('_', '-')}-helper.py"
        with open(script_path, 'w') as f:
            f.write(content)

        os.chmod(script_path, 0o755)

    def generate_full_skills_from_report(self, report_path: str) -> List[Path]:
        """Generate full skill packages from pattern detection report"""
        with open(report_path) as f:
            report = json.load(f)

        # Support both pattern detector reports and PRD analysis reports
        recommendations = report.get("recommendations", report.get("skill_recommendations", []))
        patterns = report.get("patterns", report.get("task_patterns", []))

        if not recommendations:
            print("No recommendations found in report")
            return []

        generated_dirs = []

        for rec in recommendations:
            related_patterns = [p for p in patterns if any(
                sp in p.get("description", "")
                for sp in rec.get("supporting_patterns", [])
            )]

            skill_dir = self.generate_full_skill(rec, related_patterns)
            generated_dirs.append(skill_dir)

        return generated_dirs


def main():
    parser = argparse.ArgumentParser(
        description="Synapse Directive Generator - Create skill creation guidance from pattern analysis",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate directives (for Claude with meta-skill)
  python directive_generator.py --report prd_report.json --mode directive

  # Generate full skills (for systems without meta-skill)
  python directive_generator.py --report prd_report.json --mode full-skill
        """
    )

    parser.add_argument(
        "--report",
        required=True,
        help="Path to pattern detection report (JSON)",
        type=str
    )

    parser.add_argument(
        "--output",
        help="Output directory (default: .claude/skill-directives or .claude/skills)",
        type=str
    )

    parser.add_argument(
        "--mode",
        help="Generation mode: 'directive' or 'full-skill' (default: directive)",
        choices=["directive", "full-skill"],
        default="directive"
    )

    parser.add_argument(
        "--create-index",
        help="Create index file",
        action="store_true"
    )

    args = parser.parse_args()

    if not os.path.exists(args.report):
        print(f"Error: Report file not found: {args.report}")
        return 1

    # Determine output directory
    if args.output:
        output_dir = args.output
    else:
        output_dir = ".claude/skill-directives" if args.mode == "directive" else ".claude/skills"

    generator = DirectiveGenerator(output_dir)

    if args.mode == "directive":
        print(f"🔍 Generating skill DIRECTIVES from: {args.report}")
        print(f"📁 Output directory: {output_dir}")
        print("ℹ️  Mode: Directive (for Claude with meta-skill)\n")

        directive_files = generator.generate_directives_from_report(args.report)

        if directive_files:
            print(f"\n✓ Generated {len(directive_files)} directive(s)")

            if args.create_index:
                generator.create_index_file(directive_files)
        else:
            print("\n⚠ No directives generated")

    else:  # full-skill mode
        print(f"🔧 Generating FULL SKILL PACKAGES from: {args.report}")
        print(f"📁 Output directory: {output_dir}")
        print("ℹ️  Mode: Full-Skill (for systems without meta-skill)\n")

        skill_dirs = generator.generate_full_skills_from_report(args.report)

        if skill_dirs:
            print(f"\n✓ Generated {len(skill_dirs)} complete skill package(s)")
            print("\n📦 Created skills:")
            for skill_dir in skill_dirs:
                print(f"   - {skill_dir.name}")
        else:
            print("\n⚠ No skills generated")

    return 0


if __name__ == "__main__":
    exit(main())
