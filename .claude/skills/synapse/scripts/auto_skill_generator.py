#!/usr/bin/env python3
"""
Synapse Auto Skill Generator
Surveille automatiquement les patterns Cortex et g√©n√®re les skills n√©cessaires.

Ce script est ex√©cut√© p√©riodiquement (via cron ou hook) pour:
1. Analyser les patterns Cortex
2. D√©tecter les besoins de nouveaux skills (critical/high priority)
3. G√©n√©rer automatiquement les skills avec skill-creator
4. Notifier l'utilisateur
"""

import sys
import json
from pathlib import Path
from datetime import datetime
from typing import List, Dict

# Add Cortex to path
cortex_scripts_path = Path(__file__).parent.parent.parent / "cortex" / "scripts"
sys.path.insert(0, str(cortex_scripts_path))

try:
    from cortex_api import add_cortex_event, get_pattern_analysis
    Cortex_AVAILABLE = True
except ImportError:
    Cortex_AVAILABLE = False

# Import Synapse analyzer
try:
    from nexus_analyzer import SynapseUnifiedAnalyzer
    Synapse_AVAILABLE = True
except ImportError:
    Synapse_AVAILABLE = False


class AutoSkillGenerator:
    """G√©n√®re automatiquement les skills bas√©s sur l'analyse Synapse"""

    def __init__(self, threshold: int = 5, days: int = 7, auto_generate_threshold: str = "high"):
        """
        Args:
            threshold: Seuil minimum pour d√©tecter un pattern
            days: Nombre de jours √† analyser
            auto_generate_threshold: Priorit√© minimale pour g√©n√©ration auto (critical, high, medium, low)
        """
        self.threshold = threshold
        self.days = days
        self.auto_generate_threshold = auto_generate_threshold
        self.repo_path = Path(".")
        self.skills_dir = self.repo_path / ".claude" / "skills"

    def should_auto_generate(self, priority: str) -> bool:
        """D√©termine si un skill doit √™tre g√©n√©r√© automatiquement"""
        priority_levels = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1
        }

        threshold_level = priority_levels.get(self.auto_generate_threshold, 3)
        skill_level = priority_levels.get(priority, 0)

        return skill_level >= threshold_level

    def get_existing_skills(self) -> List[str]:
        """Liste des skills existants"""
        if not self.skills_dir.exists():
            return []

        return [
            item.name for item in self.skills_dir.iterdir()
            if item.is_dir() and not item.name.startswith('.')
        ]

    def generate_skill_with_creator(self, recommendation: Dict) -> bool:
        """
        G√©n√®re un skill en utilisant skill-creator

        Returns:
            True si g√©n√©r√© avec succ√®s
        """
        skill_name = recommendation['skill_name']
        pattern_type = recommendation.get('pattern_type', 'general')

        skill_dir = self.skills_dir / skill_name

        # Cr√©er la structure du skill
        skill_dir.mkdir(parents=True, exist_ok=True)
        (skill_dir / "scripts").mkdir(exist_ok=True)
        (skill_dir / "references").mkdir(exist_ok=True)

        # G√©n√©rer SKILL.md bas√© sur le pattern
        skill_md_content = self._generate_skill_md(recommendation)
        with open(skill_dir / "SKILL.md", 'w') as f:
            f.write(skill_md_content)

        # G√©n√©rer script principal si n√©cessaire
        main_script = self._generate_main_script(recommendation)
        if main_script:
            script_path = skill_dir / "scripts" / "main.py"
            with open(script_path, 'w') as f:
                f.write(main_script)
            script_path.chmod(0o755)

        return True

    def _generate_skill_md(self, rec: Dict) -> str:
        """G√©n√®re le contenu de SKILL.md"""
        skill_name = rec['skill_name']
        pattern_type = rec.get('pattern_type', 'general')
        priority = rec.get('priority', 'medium')
        reason = rec.get('reason', 'Detected recurring pattern')

        # Extraire des exemples de contexte
        contexts = rec.get('contexts', [])
        example_section = ""
        if contexts:
            example_section = "\n## Examples from usage\n\n"
            for ctx in contexts[:3]:
                if isinstance(ctx, dict):
                    desc = ctx.get('description', str(ctx))
                    example_section += f"- {desc}\n"

        return f"""---
name: {skill_name}
description: Handles {pattern_type} operations automatically. Auto-generated by Synapse based on detected usage patterns.
---

# {skill_name.title().replace('-', ' ')}

**Auto-generated skill** - Created automatically by Synapse on {datetime.now().strftime("%Y-%m-%d")}

## Why this skill was created

{reason}

**Pattern detected:** {pattern_type}
**Priority:** {priority}
**Source:** {rec.get('source', 'Cortex patterns')}

## What this skill does

This skill automatically handles {pattern_type}-related tasks based on detected usage patterns in your project.

**Core capabilities:**
- Automatic {pattern_type} detection
- Pattern-based optimization
- Integration with Cortex memory
- Best practices for {pattern_type} operations
{example_section}
## When Claude uses this skill

Automatically activated when:
- Working with {pattern_type} patterns
- User requests {pattern_type} functionality
- Cortex detects similar patterns in current context

## Integration

This skill integrates with:
- **Cortex** - Tracks usage and learns patterns
- **Synapse** - Continuous monitoring and optimization

---

*Auto-generated by Synapse on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}*
*Based on {rec.get('count', 0)} detected occurrences*
"""

    def _generate_main_script(self, rec: Dict) -> str:
        """G√©n√®re un script principal si n√©cessaire"""
        skill_name = rec['skill_name']
        pattern_type = rec.get('pattern_type', 'general')

        return f"""#!/usr/bin/env python3
\"\"\"
{skill_name} - Auto-generated skill
Handles {pattern_type} operations based on detected patterns.
\"\"\"

import sys
from pathlib import Path

# Add Cortex to path
cortex_path = Path(__file__).parent.parent.parent / "cortex" / "scripts"
sys.path.insert(0, str(cortex_path))

try:
    from cortex_api import add_cortex_event
    Cortex_AVAILABLE = True
except ImportError:
    Cortex_AVAILABLE = False


def execute_{pattern_type.replace('-', '_')}(context: dict) -> dict:
    \"\"\"
    Execute {pattern_type} operation

    Args:
        context: Operation context

    Returns:
        Result dictionary
    \"\"\"
    # Track execution
    if Cortex_AVAILABLE:
        add_cortex_event(
            "{pattern_type}_execution",
            f"{{skill_name}} executed automatically",
            {{"context": str(context)}}
        )

    # Main logic here
    result = {{
        "status": "success",
        "pattern": "{pattern_type}",
        "message": "Operation completed"
    }}

    return result


if __name__ == "__main__":
    import json
    context = {{}}
    result = execute_{pattern_type.replace('-', '_')}(context)
    print(json.dumps(result, indent=2))
"""

    def run_auto_generation(self) -> Dict:
        """
        Ex√©cute la g√©n√©ration automatique de skills

        Returns:
            Dict avec r√©sultats (skills g√©n√©r√©s, skipp√©s, erreurs)
        """
        if not Synapse_AVAILABLE:
            return {
                "error": "Synapse analyzer not available",
                "generated": [],
                "skipped": []
            }

        print(f"ü§ñ Synapse Auto Skill Generator")
        print(f"   Threshold: {self.threshold} occurrences in {self.days} days")
        print(f"   Auto-generate: {self.auto_generate_threshold}+ priority\n")

        # Analyser avec Synapse
        analyzer = SynapseUnifiedAnalyzer(
            repo_path=str(self.repo_path),
            threshold=self.threshold,
            days=self.days
        )

        recommendations = analyzer.analyze_all()

        if not recommendations:
            print("‚úÖ No new skills needed - patterns below threshold\n")
            return {"generated": [], "skipped": []}

        existing_skills = self.get_existing_skills()
        generated = []
        skipped = []

        for rec in recommendations:
            skill_name = rec['skill_name']
            priority = rec['priority']

            # Skip si skill existe d√©j√†
            if skill_name in existing_skills:
                print(f"‚è≠Ô∏è  {skill_name}: Already exists")
                skipped.append({
                    "skill": skill_name,
                    "reason": "already_exists"
                })
                continue

            # Skip si priorit√© trop basse
            if not self.should_auto_generate(priority):
                print(f"‚è≠Ô∏è  {skill_name}: Priority {priority} below threshold ({self.auto_generate_threshold})")
                skipped.append({
                    "skill": skill_name,
                    "reason": f"priority_too_low_{priority}"
                })
                continue

            # G√©n√©rer le skill automatiquement
            print(f"üîß Generating {skill_name} (priority: {priority})...")

            try:
                success = self.generate_skill_with_creator(rec)

                if success:
                    print(f"   ‚úÖ {skill_name} created successfully\n")
                    generated.append({
                        "skill": skill_name,
                        "priority": priority,
                        "pattern": rec.get('pattern_type', 'unknown')
                    })

                    # Enregistrer dans Cortex
                    if Cortex_AVAILABLE:
                        add_cortex_event(
                            "skill_auto_generated",
                            f"Synapse auto-generated skill: {skill_name}",
                            {
                                "skill_name": skill_name,
                                "priority": priority,
                                "pattern_type": rec.get('pattern_type'),
                                "reason": rec.get('reason')
                            }
                        )
                else:
                    print(f"   ‚ö†Ô∏è  {skill_name} generation failed\n")
                    skipped.append({
                        "skill": skill_name,
                        "reason": "generation_failed"
                    })

            except Exception as e:
                print(f"   ‚ùå Error generating {skill_name}: {e}\n")
                skipped.append({
                    "skill": skill_name,
                    "reason": f"error_{str(e)}"
                })

        # R√©sum√©
        print("="*60)
        print(f"‚úÖ Auto-generation complete")
        print(f"   Generated: {len(generated)} skills")
        print(f"   Skipped: {len(skipped)} skills\n")

        if generated:
            print("üì¶ New skills created:")
            for skill in generated:
                print(f"   - {skill['skill']} ({skill['priority']}, {skill['pattern']})")

        return {
            "generated": generated,
            "skipped": skipped,
            "timestamp": datetime.now().isoformat()
        }


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Synapse Auto Skill Generator - G√©n√®re automatiquement les skills n√©cessaires"
    )
    parser.add_argument("--threshold", type=int, default=5, help="Pattern threshold (default: 5)")
    parser.add_argument("--days", type=int, default=7, help="Days to analyze (default: 7)")
    parser.add_argument("--auto-threshold", default="high",
                       choices=["critical", "high", "medium", "low"],
                       help="Minimum priority for auto-generation (default: high)")
    parser.add_argument("--dry-run", action="store_true",
                       help="Analyze only, don't generate skills")

    args = parser.parse_args()

    generator = AutoSkillGenerator(
        threshold=args.threshold,
        days=args.days,
        auto_generate_threshold=args.auto_threshold
    )

    if args.dry_run:
        print("üîç DRY RUN MODE - No skills will be generated\n")
        # TODO: Impl√©menter dry-run avec analyse seulement

    result = generator.run_auto_generation()

    # Return code
    if result.get("error"):
        return 1

    return 0


if __name__ == "__main__":
    sys.exit(main())
